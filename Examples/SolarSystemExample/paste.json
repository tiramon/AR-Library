{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"databank","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"local position = {0,0,0}\nlocal offsetPos = {0,0,0}\nlocal safeZones = {\n  {id = 1, name = \"Madis\", center = {17465536,22665536,-34464}, \n        satellites = {\n            {id = 10, name = \"Madis Moon 1\", center = {17448118.224,22966846.286,143078.82}},\n            {id = 11, name = \"Madis Moon 2\", center = {17194626,22243633.88,-214962.81}},\n            {id = 12, name = \"Madis Moon 3\", center = {17520614,22184730,-309989.99}}\n        }\n  },\n  {id = 2, name = \"Alioth\", center = {-8,-8,-126303}, \n        satellites = {\n            {id = 21, name = \"Alioth Moon 1\", center = {457933,-1509011,115524}},\n            {id = 22, name = \"Alioth Moon 4\", center = {-1692694,729681,-411464}},\n            {id = 26, name = \"Sanctuary Moon\", center = {-1404835,562655,-285074}}\n        }\n  },\n  {id = 3, name = \"Thades\", center = {29165536,10865536,65536}, \n        satellites = {\n            {id = 30, name = \"Thades Moon 1\", center = {29214402,10907080.695,433858.2}},\n            {id = 31, name = \"Thades Moon 2\", center = {29404193,10432768,19554.131}}\n        }\n  },\n  {id = 4, name = \"Talemai\", center = {-13234464,55765536,465536}, \n        satellites = {\n            {id = 42, name = \"Talemai Moon 1\", center = {-13058408,55781856,740177.76}},\n            {id = 40, name = \"Talemai Moon 2\", center = {-13503090,55594325,769838.64}},\n            {id = 41, name = \"Talemai Moon 3\", center = {-12800515,55700259,325207.84}}\n        }\n  },\n  {id = 5, name = \"Feli\", center = {-43534464,22565536,-48934464}, \n        satellites = {\n            {id = 50, name = \"Feli Moon 1\", center = {-43902841.78,22261034.7,-48862386}}\n        }\n  },\n  {id = 6, name = \"Sicari\", center = {52765536,27165538,52065535}},\n  {id = 7, name = \"Sinnen\", center = {58665538,29665535,58165535}, \n        satellites = {\n            {id = 70, name = \"Sinnen Moon 1\", center = {58969616,29797945,57969449}}\n        }\n  },\n  {id = 8, name = \"Teoma\", center = {80865538,54665536,-934463.94}},\n  {id = 9, name = \"Jago\", center = {-94134462,12765534,-3634464}},\n  {id = 100, name = \"Lacobus\", center = {98865536,-13534464,-934461.99}, \n        satellites = {\n            {id = 102, name = \"Lacobus Moon 1\", center = {99180968,-13783862,-926156.4}},\n            {id = 103, name = \"Lacobus Moon 2\", center = {99250052,-13629215,-1059341.4}},\n            {id = 101, name = \"Lacobus Moon 3\", center = {98905288.17,-13950921.1,-647589.53}} \n        }\n  },\n  {id = 110, name = \"Symeon\", center = {14165536,-85634465,-934464.3}},\n  {id = 120, name = \"Ion\", center = {2865536.7,-99034464,-934462.02}, \n        satellites = {\n            {id = 121, name = \"Ion Moon 1\", center = {2472916.8,-99133747,-1133582.8}},\n            {id = 122, name = \"Ion Moon 2\", center = {2995424.5,-99275010,-1378480.7}}\n        }\n  },\n  {name = \"Tutorial Planet\", center = {84000000016.5690,92999999983.4165,54000000022.9705}}\n}\n\nlocal orientation = {0,0,0}\nlocal width = system.getScreenWidth() / 2\nlocal height = system.getScreenHeight() / 2\nlocal objectBuilder = ObjectBuilderLinear()\n\nlocal camera = Camera(cameraTypes.player.construct, {0,0,0}, {0,0,0})\nprojector = Projector(core, camera)\n\nlocal planetGroup = ObjectGroup(\"PlanetGroup\")\nprojector.addObjectGroup(planetGroup)\n\nplanets = objectBuilder\n   \t\t\t.setStyle(\"obj\")\n   \t\t\t.setPosition({0,5,0}) --x,y,z\n   \t\t\t.setOffset({0,0,0}) --x,y,z\n   \t\t\t.setOrientation({0,0,0}) --pitch,heading,roll\n   \t\t\t.setPositionType(positionTypes.localP)\n   \t\t\t.setOrientationType(orientationTypes.localO)\n   \t\t\t.build()\nship = objectBuilder\n\t\t\t\t.setStyle(\"ship\") -- Sets the class of this graphic\n\t\t\t\t.setPosition(position) -- Sets the position of the object, around which it rotates\n\t\t\t\t.setOffset(offsetPos) -- Sets the offset, usually not used but sometimes useful\n\t\t\t\t.setOrientation(orientation) -- Sets the default pitch, heading and roll (in degrees)\n\t\t\t\t.setPositionType(positionTypes.localP) -- Sets how the position relates to the world.\n\t\t\t\t.setOrientationType(orientationTypes.localO) -- Sets how the orientation relates to the world.\n\t\t\t\t.build() -- creates the object\nplanetGroup.addObject(planets)\n-- Now to actually add data to the planets, we do the following.\nlocal scale = 50000000 -- i.e. 1:50000000\nlocal planetCircles = planets.setCircles(1, \"planets\", scale)\n-- We use \"set circles\" because we we don't really care about scaling the object.\n-- It also is just simpler this way.\nfor ii = 1, #safeZones do\n    local safeZone = safeZones[ii]\n    planetCircles --Position, size and fill respectively\n    \t.addCircle(safeZone.center, 5, \"orange\") -- I can add a circle in a chain like this.\n    \t.setLabel(safeZone.name) -- Adds the label to it. Labels are basic at the moment.\n    \t.build() -- Tells the program you are done with creating it and adds it.\nend\n\nship.setCircles(1, \"Player\", 50000000).addCircle({0,0,0}, 3, \"green\").setLabel(\"Me\").build()\n-- ^ Adds a a green circle at 0,0,0 of the *object* with a radius of 3.\nplanets.addSubObject(ship)\n\nunit.setTimer(\"fixed_1\", 1/1000)\nunit.setTimer(\"update\", 1/1000)\nsystem.showScreen(1)\nunit.hide()\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"local concat = table.concat\nlocal svg, index = projector.getSVG()\n\nlocal width = system.getScreenWidth()\nlocal height = system.getScreenHeight()\nsvg[index] =\n[[\n<style>\nsvg{ width:]]..width ..[[px; height:]]..height ..[[px; position:absolute; top:0px; left:0px;}\n.Player{stroke: red; fill: white; text-align: center;}\n.PlanetGroup{filter: drop-shadow(0 0 0.5rem black);}\n.planets{ stroke: #defff0; fill: white; text-align: center;}\n</style>]]\nlocal rendered = concat(svg)\nsystem.setScreen(rendered)","filter":{"args":[{"value":"update"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"projector.updateCamera()\nplanets.rotateHeading(0.5)\nlocal position = core.getConstructWorldPos()\nlocal scale = 50000000\n-- Sets the position of the ship, but since our previous version was scaled, so too should our position.\n-- Additionally, we do need to move the position 5 meters forward because we moved our planet group 5 meters forward earlier.\nship.setPosition(position[1] / scale, position[2] / scale, position[3] / scale)","filter":{"args":[{"value":"fixed_1"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"function Projector(core, camera)\n    -- Localize frequently accessed data\n    local utils=require('cpml.utils')\n    local library=library\n    local core=core\n    local unit=unit\n    local system=system\n    local manager=getManager()\n    \n    -- Localize frequently accessed functions\n    --- Library-based function calls\n    local solve=library.systemResolution3\n    \n    --- System-based function calls\n    local getWidth=system.getScreenWidth\n    local getHeight=system.getScreenHeight\n    local getFov=system.getFov\n    local getMouseDeltaX=system.getMouseDeltaX\n    local getMouseDeltaY=system.getMouseDeltaY\n    local getPlayerWorldPos=system.getPlayerWorldPos\n    local print=system.print\n    \n    --- Core-based function calls\n    local getCWorldPos=core.getConstructWorldPos\n    local getCWorldOriR=core.getConstructWorldOrientationRight\n    local getCWorldOriF=core.getConstructWorldOrientationForward\n    local getCWorldOriU=core.getConstructWorldOrientationUp\n    local getCLocalOriR=core.getConstructOrientationRight\n    local getCLocalOriF=core.getConstructOrientationForward\n    local getCLocalOriU=core.getConstructOrientationUp\n    local getElementPositionById=core.getElementPositionById\n    local getElementRotationById=core.getElementRotationById\n    \n    --- Unit-based function calls\n    local getRelativeOrientation=unit.getMasterPlayerRelativeOrientation\n    \n    --- Camera-based function calls\n    local getAlignmentType=camera.getAlignmentType\n    \n    --- Manager-based function calls\n    ---- Positional Operations\n    local getLocalToWorldConverter=manager.getLocalToWorldConverter\n    local getWorldToLocalConverter=manager.getWorldToLocalConverter\n    local getTrueWorldPos=manager.getTrueWorldPos\n    local getPlayerLocalPos=manager.getPlayerLocalPos\n    ---- Quaternion operations\n    local inverse,multiply,divide,rotToEuler,rotToQuat=manager.inverse,manager.multiply,manager.divide,manager.rotMatrixToEuler,manager.rotMatrixToQuat\n    \n    -- Localize Math functions\n    local sin,cos,tan,rad,deg,sqrt,atan,ceil,floor=math.sin,math.cos,math.tan,math.rad,math.deg,math.sqrt,math.atan,math.ceil,math.floor\n\n    -- Projection infomation\n    --- Screen Parameters\n    local width = getWidth()*0.5\n    local height = getHeight()*0.5\n\n    --- FOV Paramters\n    \n    --local offset = (width + height) / 5000\n    local offset=0\n    local hfovRad=rad(getFov()+offset)\n    local tanFov=tan(hfovRad*0.5)*height/width\n\n    --- Matrix Subprocessing\n    local aspect=width/height\n    local near=width/tanFov\n    local top=near*tanFov\n    local bottom=-top\n    local left=bottom*aspect\n    local right=top*aspect\n\n    --- Matrix Paramters\n    local x0=2*near/(right-left)\n    local y0=2*near/(top-bottom)\n    \n    -- Player-related values\n    local playerId=unit.getMasterPlayerId()\n    local unitId=unit.getId()\n    \n    -- Camera-Related values\n    local eye=camera.position\n    local cOrientation=camera.orientation\n    local cameraType=camera.cType\n    local alignmentType=nil\n    \n    --- Mouse info\n    local sensitivity=1 --export: Sensitivtiy\n    local m=sensitivity*(width*2)*0.00104584100642898+0.00222458611638299\n\n    local bottomLock=false\n    local topLock=false\n    local rightLock=false\n    local leftLock=false\n\n    local objectGroups={}\n    \n    local self={objectGroups=objectGroups}\n\n    function self.getSize(size,zDepth,max,min)\n        local pSize=atan(size,zDepth)*(near/aspect)\n        local max=max or pSize\n        local min=min or pSize\n        if pSize>=max then return max\n        elseif pSize<=min then return min\n        else return pSize end\n    end\n    \n    function self.updateCamera()\n        if cameraType.name~=\"fGlobal\" and cameraType.name~=\"fLocal\" then\n            -- Localize variables\n            local atan=atan\n            \n            eye=getPlayerLocalPos(playerId)\n\n            local deltaMouseX,deltaMouseY=getMouseDeltaX(),getMouseDeltaY()\n            local width=width\n            local deltaPitch=atan(-deltaMouseY,width)*m\n            local deltaHeading=atan(deltaMouseX,width)*m\n        \n            local pPitch=cOrientation[1]\n            local pHeading=cOrientation[2]\n            \n            local alignType=alignmentType\n            if alignType==nil then alignType=getAlignmentType() end\n            \n            local pitPos,pitNeg=alignType.pitchPos,alignType.pitchNeg\n            local headPos,headNeg=alignType.headingPos,alignType.headingNeg\n            \n            if pitPos~=nil then\n                if not(bottomLock or topLock) then  \n                    pPitch=pPitch+deltaPitch\n                    if pPitch<=pitNeg then\n                        pPitch=pitNeg\n                        bottomLock=true\n                    end\n                    if pPitch>=pitPos then\n                        pPitch=pitPos\n                        topLock=true\n                    end\n                else\n                    if bottomLock and deltaMouseY<0 then\n                        bottomLock=false\n                        pPitch=pPitch+deltaPitch\n                    end\n                    if topLock and deltaMouseY>0 then\n                        topLock=false\n                        pPitch=pPitch+deltaPitch\n                    end\n                end\n                cOrientation[1]=pPitch\n            else\n                cOrientation[1]=0\n            end\n            if headPos ~= nil then\n                if not(leftLock or rightLock) then  \n                    pHeading=pHeading+deltaHeading\n                    if pHeading<=headNeg then\n                        pHeading=headNeg\n                        leftLock=true\n                    end\n                    if pHeading>=headPos then\n                        pHeading=headPos\n                        rightLock=true\n                    end\n                else\n                    if rightLock and deltaMouseX<0 then\n                        rightLock=false\n                        pHeading=pHeading+deltaHeading\n                    end\n                    if leftLock and deltaMouseX>0 then\n                        leftLock=false\n                        pHeading=pHeading+deltaHeading\n                    end\n                end\n                cOrientation[2]=pHeading\n            else\n                cOrientation[2]=0\n            end\n        end\n    end\n\n    function self.addObjectGroup(objectGroup, id)\n        local index=id or #objectGroups+1\n        objectGroups[index]=objectGroup\n        return index\n    end\n\n    function self.removeObjectGroup(id)\n    \tobjectGroups[id]={}\n    end\n    \n    local sx,sy,sz,sw = 0,0,0,1\n    local lx,ly,lz,lw = 0,0,0,1\n    local cUX,cUY,cUZ = nil,nil,nil\n    local cFX,cFY,cFZ = nil,nil,nil\n    local cRX,cRY,cRZ = nil,nil,nil\n    \n    function self.getModelMatrices(mObject)\n        local s,c,multi,inverse=sin,cos,multiply,inverse\n        local modelMatrices={}\n            \n        -- Localize Object values.\n        local obj=mObject\n        local objOri=obj[9]\n        local objPos=obj[11]\n        local objPosX,objPosY,objPosZ=objPos[1],objPos[2],objPos[3]\n        \n        local cUX,cUY,cUZ=cUX,cUY,cUZ\n        local cFX,cFY,cFZ=cFX,cFY,cFZ\n        local cRX,cRY,cRZ=cRX,cRY,cRZ\n        local sx,sy,sz,sw=sx,sy,sz,sw\n        \n        local recurse={}\n        local ct=2\n        function recurse.subObjectMatrices(kx,ky,kz,kw,sObjX,sObjY,sObjZ,object,posLX,posLY,posLZ)\n            local objPos=object[11]\n            local objRot=object[9]\n            local objX,objY,objZ=objPos[1],objPos[2],objPos[3]\n            \n            local objP,objH,objR=objRot[1]*0.5,objRot[2]*0.5,objRot[3]*0.5\n            local sP,sH,sR=s(objP),s(objR),s(objH)\n            local cP,cH,cR=c(objP),c(objR),c(objH)\n    \n            local wwx,wwy,wwz,www=sP*cH*cR-cP*sH*sR,cP*sH*cR+sP*cH*sR,cP*cH*sR-sP*sH*cR,cP*cH*cR+sP*sH*sR\n            local wx,wy,wz,ww=wwx,wwy,wwz,www\n\n            local lix,liy,liz,liw=inverse(kx,ky,kz,kw)\n            \n            local posTX,posTY,posTZ,posTW=multi(kx,ky,kz,kw,objX,objY,objZ,0)\n\n            local posIX=-posTX*liw+posTW*lix-posTY*liz-posTZ*liy\n            local posIY=posTY*liw+posTW*liy+posTZ*lix-posTX*liz\n            local posIZ=-posTZ*liw+posTW*liz+posTX*liy+posTY*lix\n            if object[7]==2 then\n                local dotX=cRX*posIX+cFX*posIY+cUX*posIZ\n                local dotY=cRY*posIX+cFY*posIY+cUY*posIZ\n                local dotZ=cRZ*posIX+cFZ*posIY+cUZ*posIZ\n                posIX=dotX\n                posIY=dotY\n                posIZ=dotZ\n            end\n            posIX,posIY,posIZ=posIX+posLX,posIY+posLY,posIZ+posLZ\n            if object[8]==2 then\n                wx,wy,wz,ww=multi(wx,wy,wz,ww,sx,sy,sz,sw)\n            end\n            \n            local wxwx,wxwy,wxwz,wxww,wywy,wywz,wyww,wzwz,wzww=wx*wx,wx*wy,wx*wz,wx*ww,wy*wy,wy*wz,wy*ww,wz*wz,wz*ww\n            local a1 = 1-2*(wywy+wzwz)\n            local b1 = 2*(wxwy-wzww)\n            local c1 = 2*(wxwz+wyww)\n    \n            local d1 = 2*(wxwy+wzww)\n            local e1 = 1-2*(wxwx+wzwz)\n            local f1 = 2*(wywz-wxww)\n    \n            local g1 = 2*(wxwz-wyww)\n            local h1 = 2*(wywz+wxww)\n            local i1 = 1-2*(wxwx+wywy)\n            \n            modelMatrices[ct]={object,{a1,-d1,-g1,posIX,-b1,e1,h1,-posIY,-c1,f1,i1,-posIZ,0,0,0,1}}\n            ct=ct+1\n            \n            local subObjects=object[6]\n            if #subObjects>0 then\n                for k=1,#subObjects do\n                    local subObj=subObjects[k]\n                    if subObj[11]~=nil then\n                        recurse.subObjectMatrices(wwx,wwy,wwz,www,objX,objY,objZ,subObj,posIX,posIY,posIZ)\n                    end\n                end\n            end\n        end\n        local pitch,heading,roll=objOri[1]*0.5,objOri[2]*0.5,objOri[3]*0.5\n        \n        --- Quaternion of object rotations\n        local sP,sH,sR=s(pitch),s(roll),s(heading)\n        local cP,cH,cR=c(pitch),c(roll),c(heading)\n    \n        local wwx=(sP*cH*cR-cP*sH*sR)\n        local wwy=(cP*sH*cR+sP*cH*sR)\n        local wwz=(cP*cH*sR-sP*sH*cR)\n        local www=(cP*cH*cR+sP*sH*sR)\n        local wx,wy,wz,ww=wwx,wwy,wwz,www\n        \n        if obj[8]==2 then\n            wx,wy,wz,ww=multiply(wx,wy,wz,ww,sx,sy,sz,sw)\n        end\n        \n        local wxwx,wxwy,wxwz,wxww,wywy,wywz,wyww,wzwz,wzww=wx*wx,wx*wy,wx*wz,wx*ww,wy*wy,wy*wz,wy*ww,wz*wz,wz*ww\n        local a2=1-2*(wywy+wzwz)\n        local b2=2*(wxwy-wzww)\n        local c2=2*(wxwz+wyww)\n    \n        local d2=2*(wxwy+wzww)\n        local e2=1-2*(wxwx+wzwz)\n        local f2=2*(wywz-wxww)\n    \n        local g2=2*(wxwz-wyww)\n        local h2=2*(wywz+wxww)\n        local i2=1-2*(wxwx+wywy)\n\n        if obj[7]==2 then\n            local dotX=cRX*objPosX+cFX*objPosY+cUX*objPosZ\n            local dotY=cRY*objPosX+cFY*objPosY+cUY*objPosZ\n            local dotZ=cRZ*objPosX+cFZ*objPosY+cUZ*objPosZ\n            objPosX=dotX\n            objPosY=dotY\n            objPosZ=dotZ\n        else\n            local cWorldPos=getTrueWorldPos()\n            objPosX=objPosX-cWorldPos[1]\n            objPosY=objPosY-cWorldPos[2]\n            objPosZ=objPosZ-cWorldPos[3]\n        end\n        local subObjs=obj[6]\n        if #subObjs>0 then\n            for k=1,#subObjs do\n                local subObj=subObjs[k]\n                if subObj[6]~= nil then\n                    recurse.subObjectMatrices(wwx,wwy,wwz,www,objPos[1],objPos[2],objPos[3],subObj,objPosX,objPosY,objPosZ)\n                end\n            end\n        end\n        modelMatrices[1]={obj,{a2,-d2,-g2,objPosX,-b2,e2,h2,-objPosY,-c2,f2,i2,-objPosZ,0,0,0,1}}\n        return modelMatrices\n    end\n\n    local function updateReferentials()\n        local s = solve\n        local cU,cF,cR = getCWorldOriU(),getCWorldOriF(),getCWorldOriR()\n        local ccUX,ccUY,ccUZ,ccFX,ccFY,ccFZ,ccRX,ccRY,ccRZ=cU[1],cU[2],cU[3],cF[1],cF[2],cF[3],cR[1],cR[2],cR[3]\n        local v1t,v2t,v3t=s(cR,cF,cU,{1,0,0}),s(cR,cF,cU,{0,1,0}),s(cR,cF,cU,{0,0,1})\n        cRX,cRY,cRZ,cFX,cFY,cFZ,cUX,cUY,cUZ=ccRX,ccRY,ccRZ,ccFX,ccFY,ccFZ,ccUX,ccUY,ccUZ\n        sx,sy,sz,sw=rotToQuat({ccRX,ccRY,ccRZ,0,ccFX,ccFY,ccFZ,0,ccUX,ccUY,ccUZ,0})\n        lx,ly,lz,lw=rotToQuat({v1t[1],v1t[2],v1t[3],0,v2t[1],v2t[2],v2t[3],0,v3t[1],v3t[2],v3t[3],0})\n    end\n    \n    function self.getViewMatrix()\n        updateReferentials()\n        local s,c,multi,solve=sin,cos,multiply,solve\n\n        local board=getElementRotationById(unitId)\n        local ax,ay,az,aw=board[1],board[2],board[3],board[4]\n        \n        local body=getRelativeOrientation()\n        local bx,by,bz,bw=body[1],body[2],body[3],body[4]\n        \n        local sx,sy,sz,sw=lx,ly,lz,lw\n\n        local eye=eye\n        local eyeX,eyeY,eyeZ=eye[1],eye[2],eye[3]\n\n        local dotX,dotY,dotZ=eyeX,eyeY,eyeZ\n        local wx,wy,wz,ww=0,0,0,1\n        \n        local px,py,pz,pw=multi(ax,ay,az,aw,bx,by,bz,bw)\n        local alignment=getAlignmentType(px,py,pz,pw,eyeX,eyeY,eyeZ)\n        alignmentType=alignment\n        local pix,piy,piz,piw=inverse(px,py,pz,pw)\n        local shift=alignment.shift\n            \n        local eyeTX,eyeTY,eyeTZ,eyeTW=multi(px,py,pz,pw,shift[1],shift[2],shift[3],0)\n        local eyeIX,eyeIY,eyeIZ,eyeIW=multi(eyeTX,eyeTY,eyeTZ,eyeTW,pix,piy,piz,piw)\n        \n        local alignName=alignment.name\n        local nFG=alignName~=\"fGlobal\"\n        local fG=alignName==\"fGlobal\"\n        local nFL=alignName~=\"fLocal\"\n        local fL=alignName==\"fLocal\"\n        local ori=cOrientation\n        local pitch,roll,heading=ori[1]*0.5,0,ori[2]*0.5\n        if pitch~=0 or heading~=0 or roll~=0 or fG or fL then\n            local sP,sH,sR=s(pitch),s(roll),s(heading)\n            local cP,cH,cR=c(pitch),c(roll),c(heading)\n            \n            local cx=sP*cH*cR-cP*sH*sR\n            local cy=-cP*sH*cR-sP*cH*sR\n            local cz=-cP*cH*sR+sP*sH*cR\n            local cw=cP*cH*cR+sP*sH*sR\n            if nFG and nFL then px,py,pz,pw=multi(px,py,pz,pw,cx,cy,cz,cw)\n            elseif alignName==\"fGlobal\" then wx,wy,wz,ww=cx,cy,cz,cw\n            else wx,wy,wz,ww = multi(sx,sy,sz,sw,cx,cy,cz,cw) end\n        end\n        \n        if nFG and nFL then\n            local pxpx,pxpy,pxpz,pxpw,pypy,pypz,pypw,pzpz,pzpw=px*px,px*py,px*pz,px*pw,py*py,py*pz,py*pw,pz*pz,pz*pw\n            local a1=1-2*(pypy+pzpz)\n            local b1=2*(pxpy-pzpw)\n            local c1=2*(pxpz+pypw)\n    \n            local d1=2*(pxpy+pzpw)\n            local e1=1-2*(pxpx+pzpz)\n            local f1=2*(pypz-pxpw)\n    \n            local g1=2*(pxpz-pypw)\n            local h1=2*(pypz+pxpw)\n            local i1=1-2*(pxpx+pypy)\n            eyeX=eyeX-eyeIX\n            eyeY=eyeY+eyeIY\n            eyeZ=eyeZ+eyeIZ\n        \n            dotX=a1*eyeX+-d1*eyeY+-g1*eyeZ\n            dotY=-b1*eyeX+e1*eyeY+h1*eyeZ\n            dotZ=-c1*eyeX+f1*eyeY+i1*eyeZ\n            wx,wy,wz,ww=multi(sx,sy,sz,sw,px,py,pz,pw)\n        end\n        -- Camera rotation determination\n        --- Directly input euler angles in radians\n        \n        local wxwx,wxwy,wxwz,wxww,wywy,wywz,wyww,wzwz,wzww=wx*wx,wx*wy,wx*wz,wx*ww,wy*wy,wy*wz,wy*ww,wz*wz,wz*ww\n        local a2=1-2*(wywy+wzwz)\n        local b2=2*(wxwy-wzww)\n        local c2=2*(wxwz+wyww)\n    \n        local d2=2*(wxwy+wzww)\n        local e2=1-2*(wxwx+wzwz)\n        local f2=2*(wywz-wxww)\n    \n        local g2=2*(wxwz-wyww)\n        local h2=2*(wywz+wxww)\n        local i2=1-2*(wxwx+wywy)\n\n        return {a2,-d2,-g2,dotX,-b2,e2,h2,dotY,-c2,f2,i2,dotZ,0,0,0,1}\n    end\n    \n    function self.getSVG()\n        local svg={}\n        local c=1\n        local view=self.getViewMatrix()\n\n        local vx1,vy1,vz1,vw1=view[1],view[2],view[3],view[4]\n        local vx2,vy2,vz2,vw2=view[5],view[6],view[7],view[8]\n        local vx3,vy3,vz3,vw3=view[9],view[10],view[11],view[12]\n        \n        local getSize,sort=self.getSize,table.sort\n        \n        local function trigSort(t1,t2)\n            return t1[1]>t2[1]\n        end\n\n        local function createLabel(svg,c,x,y,text,size,opacity,fill)\n            svg[c]='<text x=\"'\n            svg[c+1]=x\n            svg[c+2]='\" y=\"'\n            svg[c+3]=y\n            c=c+4\n            if opacity then\n                svg[c]='\" fill-opacity=\"'\n                svg[c+1]=opacity\n                svg[c+2]='\" stroke-opacity=\"'\n                svg[c+3]=opacity\n                c=c+4\n            end\n            if fill then\n                svg[c]='\" fill=\"'\n                svg[c+1]=fill\n                c=c+2\n            end\n            if size then\n                svg[c]='\" font-size=\"'\n                svg[c+1]=size\n                c=c+2\n            end\n            \n            svg[c]='\">'\n            svg[c+1]=text\n            svg[c+2]='</text>'\n            return c+3\n        end\n        -- Localize projection matrix values\n        local px1=x0\n        local pz3=y0\n        \n        -- Localize screen info\n        local width=width\n        local height=height\n\n        local objectGroups=objectGroups\n        for i = 1, #objectGroups do\n            local objectGroup=objectGroups[i]\n            if objectGroup.enabled==false then goto not_enabled end\n            local objGTransX=objectGroup.transX or width\n            local objGTransY=objectGroup.transY or height\n            local objects=objectGroup.objects\n            \n            svg[c]=[[<svg viewBox=\"0 0 ]]\n            svg[c+1]=width*2\n            svg[c+2]=[[ ]]\n            svg[c+3]=height*2\n            svg[c+4]=[[\" class=\"]]\n            svg[c+5]=objectGroup.style\n            svg[c+6]='\"><g transform=\"translate('\n            svg[c+7]=objGTransX\n            svg[c+8]=','\n            svg[c+9]=objGTransY\n            svg[c+10]=')\">'\n            c=c+11\n            for m=1,#objects do\n                local obj=objects[m]\n                if obj[11]==nil then goto is_nil end\n                local models=self.getModelMatrices(obj)\n                -- Localize model matrix values\n                for k=1,#models do\n                    local modelObj=models[k]\n                    local object=modelObj[1]\n                    local model=modelObj[2]\n                    \n                    local objStyle=object[10]\n                    local objTransX=object[13] or 0\n                    local objTransY=object[14] or 0\n                    \n                    svg[c]='<g class=\"'\n                    svg[c+1]=objStyle\n                    c=c+2\n                    if objTransX~=0 or objTransY~=0 then\n                        svg[c]='\" transform=\"translate('\n                        svg[c+1]=objTransX\n                        svg[c+2]=','\n                        svg[c+3]=objTransY\n                        svg[c+4]=')'\n                        c=c+5\n                    end\n                    svg[c]='\">'\n                    c=c+1\n                    local mx1,my1,mz1,mw1=model[1],model[2],model[3],model[4]\n                    local mx2,my2,mz2,mw2=model[5],model[6],model[7],model[8]\n                    local mx3,my3,mz3,mw3=model[9],model[10],model[11],model[12]\n                \n                    local pxw = px1*width            \n                    local mXX=(vx1*mx1+vy1*mx2+vz1*mx3)*pxw\n                    local mXY=(vx1*my1+vy1*my2+vz1*my3)*pxw\n                    local mXZ=(vx1*mz1+vy1*mz2+vz1*mz3)*pxw\n                    local mXW=(vw1+vx1*mw1+vy1*mw2+vz1*mw3)*pxw\n        \n                    local mYX=(vx2*mx1+vy2*mx2+vz2*mx3)\n                    local mYY=(vx2*my1+vy2*my2+vz2*my3)\n                    local mYZ=(vx2*mz1+vy2*mz2+vz2*mz3)\n                    local mYW=(vw2+vx2*mw1+vy2*mw2+vz2*mw3)\n        \n                    local pzw=pz3*height\n                    local mZX=(vx3*mx1+vy3*mx2+vz3*mx3)*pzw\n                    local mZY=(vx3*my1+vy3*my2+vz3*my3)*pzw\n                    local mZZ=(vx3*mz1+vy3*mz2+vz3*mz3)*pzw\n                    local mZW=(vw3+vx3*mw1+vy3*mw2+vz3*mw3)*pzw\n                \n                    local polylineGroups,circleGroups,curvesGroups,customGroups,triangleGroups=object[1],object[2],object[3],object[4],object[5]            \n            \n                    -- Polylines for-loop\n                    for d=1,#polylineGroups do\n                        local polylineGroup = polylineGroups[d]\n                        svg[c]='<path class=\"'\n                        svg[c+1]=polylineGroup[1]\n                        svg[c+2]='\" d=\"'\n                        c=c+3\n                        for f=2,#polylineGroup do\n                            local line=polylineGroup[f]\n                            svg[c]='M '\n                            local lC=0\n                            local sP={}\n                            local eP={}\n                            c=c+1\n                            for h=1,#line do\n                                local p=line[h]\n                                local x,y,z=p[1],-p[2],-p[3]\n                                local pz=mYX*x+mYY*y+mYZ*z+mYW\n                                if pz>0 then goto behindLine end\n\n                                local ww=-pz\n                                local wx=(mXX*x+mXY*y+mXZ*z+mXW)/ww\n                                local wy=(mZX*x+mZY*y+mZZ*z+mZW)/ww\n                                if lC~=0 then\n                                    svg[c]=' L '\n                                    c=c+1\n                                    eP={wx,wy}\n                                else\n                                    sP={wx,wy}\n                                end\n                                svg[c]=wx\n                                svg[c+1]=' '\n                                svg[c+2]=wy\n                                c=c+3\n                                lC=lC+1\n                                ::behindLine::\n                            end\n                            if lC < 2 then\n                                if lC == 1 then c=c-4\n                                else c=c-1 end\n                            else\n                                if eP[1]==sP[1] and eP[2]==sP[2] then\n                                    svg[c-4]=' Z '\n                                    c=c-3\n                                end\n                            end\n                        end\n                        svg[c] = '\"/>'\n                        c=c+1\n                    end\n                    for cG=1,#circleGroups do\n                        local circleGroup=circleGroups[cG]\n                        svg[c]='<g class=\"'\n                        svg[c+1]=circleGroup[1]\n                        svg[c+2]='\">'\n                        c=c+3\n                        for l=2,#circleGroup do\n                            local cir=circleGroup[l]\n                            local p=cir[1]\n                            local x,y,z=p[1],-p[2],-p[3]\n                            local pz=mYX*x+mYY*y+mYZ*z+mYW\n                            if pz>0 then goto behindCircle end\n\n                            local ww=-pz\n                            local wx=(mXX*x+mXY*y+mXZ*z+mXW)/ww\n                            local wy=(mZX*x+mZY*y+mZZ*z+mZW)/ww\n                            local radius,fill,label,offX,offY,size,resize,action=cir[2],cir[3],cir[4],cir[5],cir[6],cir[7],cir[8],cir[9]\n                            svg[c]='<circle cx=\"'\n                            svg[c+1]=wx\n                            svg[c+2]='\" cy=\"'\n                            svg[c+3]=wy\n                            svg[c+4]='\" r=\"'\n                            svg[c+5]=radius\n                            svg[c+6]='\" fill=\"'\n                            svg[c+7]=fill\n                            svg[c+8]='\"/>'\n                            c=c+9\n                            if label then\n                                svg[c]='<text x=\"'\n                                svg[c+1]=wx+offX\n                                svg[c+2]='\" y=\"'\n                                svg[c+3]=wy+offY\n                                c=c+4\n                                if size then\n                                    if resize==true then\n                                        svg[c]='\" font-size=\"'\n                                        svg[c+1]=getSize(size, wz)\n                                    else\n                                        svg[c]='\" font-size=\"'\n                                        svg[c+1]=size\n                                    end\n                                    c=c+2\n                                end\n                                svg[c]='\">'\n                                svg[c+1]=label\n                                svg[c+2]='</text>'\n                                c=c+3\n                                end\n                            if action then\n                                c=action(svg, c, object, wx, wy, wz)\n                            end\n                            ::behindCircle::\n                        end\n                        svg[c]='</g>'\n                        c=c+1\n                    end\n                    for cuG=1,#curvesGroups do\n                        local curveG=curvesGroups[cuG]\n                        svg[c]='<g class=\"'\n                        svg[c+1]=curveG[1]\n                        svg[c+2]='\">'\n                        c=c+3\n                        local curveG=curvesGroups[cuG]\n                        svg[c]='<path d=\"'\n                        c=c+1\n                        local curves=curveG[2]\n                        local sLabelDat={}\n                        local sLDC=0\n                        for cCt=1,#curves do\n                            local curve=curves[cCt]\n                            if curve[1]==1 then\n                                local pts=curve[2]\n                                local labelDat=curve[3]\n                                local tPts={}\n                                for i=1,12 do\n                                    local p=pts[i]\n                                    local x,y,z=p[1],-p[2],-p[3]\n                                    local pz=mYX*x+mYY*y+mYZ*z+mYW\n                                    if pz>0 then tPts[i]={0,0,false}; goto continueCurve end\n                                    \n                                    local ww=-pz\n                                    tPts[i]={(mXX*x+mXY*y+mXZ*z+mXW)/ww,(mZX*x+mZY*y+mZZ*z+mZW)/ww,true}\n                                    ::continueCurve::\n                                end\n                                local m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12=tPts[1],tPts[2],tPts[3],tPts[4],tPts[5],tPts[6],tPts[7],tPts[8],tPts[9],tPts[10],tPts[11],tPts[12]\n                                local m1x,m1y,m1z,m2x,m2y,m3x,m3y,m4x,m4y,m4z=m1[1],m1[2],m1[3],m2[1],m2[2],m3[1],m3[2],m4[1],m4[2],m4[3]\n                                if m1[3] and m1[3] and m1[3] and m4z then\n                                    svg[c]='M';svg[c+1]=m1x;svg[c+2]=' ';svg[c+3]=m1y;svg[c+4]='C';svg[c+5]=m2x;svg[c+6]=' ';svg[c+7]=m2y;svg[c+8]=',';svg[c+9]=m3x;svg[c+10]=' ';svg[c+11]=m3y;svg[c+12]=',';svg[c+13]=m4x;svg[c+14]=' ';svg[c+15]=m4y\n                                    c=c+16\n                                end\n                                local m5x,m5y,m6x,m6y,m7x,m7y,m7z=m5[1],m5[2],m6[1],m6[2],m7[1],m7[2],m7[3]\n                                if m4z and m5[3] and m6[3] and m7z then\n                                    svg[c]='M';svg[c+1]=m4x;svg[c+2]=' ';svg[c+3]=m4y;svg[c+4]='C';svg[c+5]=m5x;svg[c+6]=' ';svg[c+7]=m5y;svg[c+8]=',';svg[c+9]=m6x;svg[c+10]=' ';svg[c+11]=m6y;svg[c+12]=',';svg[c+13]=m7x;svg[c+14]=' ';svg[c+15]=m7y\n                                    c=c+16\n                                end\n                                local m8x,m8y,m9x,m9y,m10x,m10y,m10z=m8[1],m8[2],m9[1],m9[2],m10[1],m10[2],m10[3]\n                                if m7z and m8[3] and m9[3] and m10z then\n                                    svg[c]='M';svg[c+1]=m7x;svg[c+2]=' ';svg[c+3]=m7y;svg[c+4]='C';svg[c+5]=m8x;svg[c+6]=' ';svg[c+7]=m8x;svg[c+8]=',';svg[c+9]=m9x;svg[c+10]=' ';svg[c+11]=m9y;svg[c+12]=',';svg[c+13]=m10x;svg[c+14]=' ';svg[c+15]=m10y\n                                    c=c+16\n                                end    \n                                local m11x,m11y,m12x,m12y=m11[1],m11[2],m12[1],m12[2]\n                                if m10z and m11[3] and m12[3] and m1z then\n                                    svg[c]='M';vg[c+1]=m10x;svg[c+2]=' ';svg[c+3]=m10y;svg[c+4]='C';svg[c+5]=m11x;svg[c+6]=' ';svg[c+7]=m11y;svg[c+8]=',';svg[c+9]=m12x;svg[c+10]=' ';svg[c+11]=m12y;svg[c+12]=',';svg[c+13]=m1x;svg[c+14]=' ';svg[c+15]=m1y\n                                    c=c+16\n                                end\n                                if labelDat[1] then\n                                    if m1z and m4z and m7z and m10z then\n                                        sLabelDat[sLDC+1]={{m1x,m1y,m1z},{m4x,m4y,m4z},{m7x,m7y,m7z},{m10x,m10y,m10z},labelDat}\n                                        sLDC=sLDC+1\n                                    end\n                                end\n                            else\n                            end\n                        end\n                        svg[c]='\"/>'\n                        c=c+1\n                        if sLDC>0 then\n                            for ll=1,sLDC do\n                                local lInfo=sLabelDat[ll]\n                                local text=dat[1]\n                                local s=dat[3]\n                                for i=1,4 do\n                                    local p=lInfo[i]\n                                    local s=s\n                                    if dat[2] then\n                                        s=getSize(s, p[3], 100, 1)\n                                    end\n                                    svg[c]='<text x=\"'\n                                    svg[c+1]=p[1]\n                                    svg[c+2]='\" y=\"'\n                                    svg[c+3]=p[2]\n                                    svg[c+4]='\" fill=\"white\" font-size=\"'\n                                    svg[c+6]=s\n                                    svg[c+7]='\">'\n                                    svg[c+8]=text\n                                    svg[c+9]='</text>'\n                                    c=c+10\n                                end\n                            end\n                        end\n                    end\n                    for cG=1,#customGroups do\n                        local customGroup=customGroups[cG]\n                        local multiGroups=customGroup[2]\n                        local singleGroups=customGroup[3]\n                        svg[c]='<g class=\"'\n                        svg[c+1]=customGroup[1]\n                        svg[c+2]='\">'\n                        c=c+3\n                        for mGC=1,#multiGroups do\n                            local multiGroup=multiGroups[mGC]\n                            local pts=multiGroup[1]\n                            local tPoints={}\n                            local ct=1\n                            for pC=1,#pts do\n                                local p=pts[pC]\n                                local x,y,z=p[1],-p[2],-p[3]\n                                local pz=mYX*x+mYY*y+mYZ*z+mYW\n                                if pz>0 then goto behindMG end\n\n                                local ww=-pz\n                                tPoints[ct]={(mXX*x+mXY*y+mXZ*z+mXW)/ww,(mZX*x+mZY*y+mZZ*z+mZW)/ww,ww}\n                                ct=ct+1\n                                ::behindMG::\n                            end\n                            if ct~=1 then\n                                local drawFunction=multiGroup[2]\n                                local data=multiGroup[3]\n                                c=drawFunction(svg,c,object,tPoints,data)\n                            end\n                        end\n                        for sGC=1,#singleGroups do\n                            local singleGroup = singleGroups[sGC]\n                            local p=singleGroup[1]\n                            local x,y,z=p[1],-p[2],-p[3]\n                            local pz=mYX*x+mYY*y+mYZ*z+mYW\n                            if pz>0 then goto behindSingle end\n                            local ww=-pz\n                            local drawFunction=singleGroup[2]\n                            local data=singleGroup[3]\n                            c=drawFunction(svg,c,object,(mXX*x+mXY*y+mXZ*z+mXW)/ww,(mZX*x+mZY*y+mZZ*z+mZW)/ww,ww,data)\n                            ::behindSingle::\n                        end\n                        svg[c]='</g>'\n                        c=c+1\n                    end\n                    for tG=1,#triangleGroups do\n                        local trigGroup=triangleGroups[tG]\n                        svg[c]='<g class=\"'\n                        svg[c+1]=trigGroup[1]\n                        svg[c+2]='\">'\n                        c=c+3\n                        local trigInfo=trigGroup[2]\n                        local pts=trigGroup[3]\n                        local transTrigs={}\n                        for b=1,#trigInfo do\n                            transTrigs[b]={-1,{},trigInfo[b][3]}\n                        end\n                        for ptI=1,#pts do\n                            local pI=pts[ptI]\n                            local p,indices=pI[1],pI[2]\n                            local x,y,z=p[1],-p[2],-p[3]\n                            local pz=mYX*x+mYY*y+mYZ*z+mYW\n                            if pz>0 then goto behindTrig end\n\n                            local ww=-pz\n                            for i=1,#indices do\n                                local triangleData=transTrigs[indices[i]]\n                                triangleData[1]=triangleData[1]+ww\n                                local points=triangleData[2]\n                                points[#points+1]={(mXX*x+mXY*y+mXZ*z+mXW)/ww,(mZX*x+mZY*y+mZZ*z+mZW)/ww}\n                            end\n                            ::behindTrig::\n                        end\n                        sort(transTrigs,trigSort)\n                        for tIdx=1,#transTrigs do\n                            local trig=transTrigs[tIdx]\n                            local tPts=trig[2]\n                            if #tPts~=3 then goto invalid end\n                            local p1,p2,p3=tPts[1],tPts[2],tPts[3]\n                            svg[c]='<path stroke=\"black\" fill=\"'\n                            svg[c+1]=trig[3]\n                            svg[c+2]='\" d=\"M'\n                            svg[c+3]=p1[1]\n                            svg[c+4]=' '\n                            svg[c+5]=p1[2]\n                            svg[c+6]=' L '\n                            svg[c+7]=p2[1]\n                            svg[c+8]=' '\n                            svg[c+9]=p2[2]\n                            svg[c+10]=' L '\n                            svg[c+11]=p3[1]\n                            svg[c+12]=' '\n                            svg[c+13]=p3[2]\n                            svg[c+14]=' Z\"/>'\n                            c=c+15\n                            ::invalid::\n                        end\n                        svg[c]='</g>'\n                        c=c+1\n                    end\n                    svg[c]='</g>'\n                    c=c+1\n                end\n                ::is_nil::\n            end\n            svg[c]='</g></svg>'\n            c=c+1\n            ::not_enabled::\n        end\n        return svg, c\n    end\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"3"},{"code":"positionTypes = {\n    globalP=1,\n    localP=2\n}\norientationTypes = {\n    globalO=1,\n    localO=2 \n}\n\nfunction ObjectGroup(style, objects, transX, transY)\n    local objects=objects or {}\n    local self={style=style,objects=objects,transX=transX,transY=transY,enabled=true}\n    function self.addObject(object, id)\n        local id=id or #objects+1\n        objects[id]=object\n        return id\n    end\n    function self.removeObject(id) objects[id] = {} end\n    function self.hide() self.enabled = false end\n    function self.show() self.enabled = true end\n    function self.isEnabled() return self.enabled end\n    return self\nend\n\nfunction Object(style, position, offset, orientation, positionType, orientationType, transX, transY)\n    local rad,print=math.rad,system.print\n    \n    local position=position\n    local positionOffset=offset\n    local heading=rad(orientation[1])\n    local pitch=rad(orientation[2])\n    local roll=rad(orientation[3])\n    \n    local style=style\n    local polylineGroups,circleGroups,curveGroups,customGroups,triangleGroups,subObjects={},{},{},{},{},{}\n    local positionType=positionType\n    local orientationType=orientationType\n    \n    local self = {polylineGroups,circleGroups,curveGroups,customGroups,triangleGroups,subObjects,\n        positionType,\n        orientationType,\n        {pitch,heading,roll},\n        style,\n        position,\n        offset,\n        transX,\n        transY\n    }\n    \n    function self.setPolylines(groupId,style,points,scale)\n        -- Polylines for-loop\n        local group={style}\n        local scale=scale or 1\n        local offset=positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        for i=2,#points+1 do\n            local line=points[i-1]\n            local newPoints={}\n            for k=1,#line do\n                local point=line[k]\n                newPoints[k]={point[1]/scale+offsetX,point[2]/scale-offsetY,point[3]/scale-offsetZ}\n            end\n            group[i]=newPoints\n        end\n        self[1][groupId]=group\n    end\n    \n    function self.setCircles(groupId,style,scale)\n        local group={style}\n        local scale=scale or 1\n        local c=2\n        self[2][groupId]=group\n        local offset=offset or positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        local self={}\n        function self.addCircle(position,radius,fill)\n            local self={}\n            local position={position[1]/scale+offsetX,position[2]/scale-offsetY,position[3]/scale-offsetZ}\n            local label,offX,offY,size,resize,action = nil,nil,nil,nil,false,nil\n\n            function self.setLabel(lab,rs,s,ofX,ofY)\n                label=lab\n                offX=ofX or 0\n                offY=ofY or 0\n                size=s or 10\n                resize=rs or false\n                return self\n            end\n            function self.setActionFunction(actionFunction)\n                action=actionFunction\n                return self\n            end\n            function self.build()\n                local circleObj={position,radius,fill,label,offX,offY,size,resize,actionFunction}\n                group[c]=circleObj\n                c=c+1\n                return circleObj,c\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCurves(groupId,style,scale)\n        local scale=scale or 1\n        local curves= {}\n        local group={style,curves}\n        local offset=positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        self[3][groupId]=group\n        local self={}\n        local c=1\n        function self.circleBuilder()\n            local self={}\n            function self.createCircle(center,radius)\n                local k=0.5522847498307933984023\n                local radius=radius/scale\n                local cX,cY,cZ=center[1]/scale+offsetX,center[2]/scale-offsetY,center[3]/scale-offsetZ\n                local cPoints={\n                    {cX,radius+cY,cZ},{radius*k+cX,radius+cY,cZ},{radius+cX,radius*k+cY,cZ},\n                    {radius+cX,cY,cZ},{radius+cX,-radius*k+cY,cZ},{radius*k+cX,-radius+cY,cZ},\n                    {cX,-radius+cY,cZ},{-radius*k+cX,-radius+cY,cZ},{-radius+cX,-radius*k+cY,cZ},\n                    {-radius+cX,cY,cZ},{-radius+cX,radius*k+cY,cZ},{-radius*k+cX,radius+cY,cZ}\n                }\n                local resize,size=false,10\n                local labelDat={nil,resize,size}\n                local self={}\n                \n                function self.setLabel(label,resize,size)\n                    local resize=resize or false\n                    local size=size*0.002 or 0.05\n                    labelDat={label,resize,size}\n                    return self\n                end\n                function self.build()\n                    local persCircleArray={1,cPoints,labelDat}\n                    curves[c]=persCircleArray\n                    c=c+1\n                    return persCircleArray,c\n                end\n                return self\n            end\n            return self\n        end\n        function self.bezierBuilder()\n            local self={}\n            function self.createCurve(sP)\n            end\n            function self.addControlPoint(cP)\n            end\n            function self.addEndPoint(eP)\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCustomSVGs(groupId,style,scale)\n        local multiPoint={}\n        local singlePoint={}\n        local group={style,multiPoint,singlePoint}\n        local scale=scale or 1\n        local mC,sC=1,1\n        self[4][groupId]=group\n        local offset=positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        local self={}\n        function self.addMultiPointSVG()\n            local points={}\n            local data=nil\n            local drawFunction=nil\n            local self={}\n            local pC=1\n            function self.addPoint(point)\n                local point=point\n                points[pC]={point[1]/scale+offsetX,point[2]/scale-offsetY,point[3]/scale-offsetZ}\n                pC=pC+1\n                return self\n            end\n            function self.bulkSetPoints(bulk)\n                points=bulk\n            end\n            function self.setData(dat)\n                data=dat\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction=draw\n                return self\n            end\n            function self.build()\n                if pC > 0 then\n                    if drawFunction ~= nil then\n                        multiPoint[mC]={points, drawFunction, data}\n                        mC=mC+1\n                        return points\n                    else print(\"WARNING! Malformed multi-point build operation, no draw function specified. Ignoring.\")\n                    end\n                else print(\"WARNING! Malformed multi-point build operation, no points specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        function self.addSinglePointSVG()\n            local point,drawFunction,data=nil,nil,nil\n            local self={}\n            function self.setPosition(position)\n                point={position[1]/scale+offsetX,position[2]/scale-offsetY,position[3]/scale-offsetZ}\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction=draw\n                return self\n            end\n            function self.setData(dat)\n                data=dat\n                return self\n            end\n            function self.build()\n                if point~=nil then\n                    if drawFunction~=nil then\n                        singlePoint[sC]={point,drawFunction,data}\n                        sC=sC+1\n                    else print(\"WARNING! Malformed single point build operation, no draw function specified. Ignoring.\")\n                    end\n                else print(\"WARNING! Malformed single point build operation, no point specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        return self\n    end\n    function self.setTriangles(groupId,style,scale)\n        local triangleInfo={}\n        local points={}\n        local group={style,triangleInfo,points}\n        local scale=scale or 1\n        local tC=1\n        local vC=1\n        self[5][groupId]=group\n        local offset=positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        local self={}\n\n        function self.addVertex(point)\n            points[vC]={{point[1]/scale+offsetX,point[2]/scale-offsetY,point[3]/scale-offsetZ},{}}\n            vC=vC+1\n            return vC-1\n        end\n        function self.addTriangle(pointIndices,normal,color)\n            for i=1,3 do\n                local index=pointIndices[i]\n                local pointInfo=points[index][2]\n                \n                pointInfo[#pointInfo+1]=tC\n            end\n            triangleInfo[tC]={{},normal,color}\n            tC=tC+1\n        end\n        return self\n    end\n    \n    function self.rotateHeading(heading) self[9][2]=self[9][2]+rad(heading) end\n    function self.rotatePitch(pitch) self[9][1]=self[9][1]+rad(pitch) end\n    function self.rotateRoll(roll) self[9][3]=self[9][3]+rad(roll) end\n    function self.setPosition(posX, posY, posZ) self[11] = {posX, posY, posZ} end\n    \n    function self.addSubObject(object, id)\n        local id=id or #self[6]+1\n        self[6][id]=object\n        return id\n    end\n    function self.removeSubObject(id)\n        self[6][id]={}\n    end\n    \n    function self.setSubObjects()\n        local self={}\n        local c=1\n        function self.addSubObject(object)\n            self[6][c]=object\n            c=c+1\n            return self\n        end\n        return self\n    end\n    \n    return self\nend\n\nfunction ObjectBuilderLinear()\n    local self={}\n    function self.setStyle(style)\n        local self={}\n        local style=style\n        function self.setPosition(pos)\n            local self={}\n            local pos=pos\n            function self.setOffset(offset)\n                local self={}\n                local offset=offset\n                function self.setOrientation(orientation)\n                    local self={}\n                    local orientation=orientation\n                    function self.setPositionType(positionType)\n                        local self={}\n                        local positionType=positionType\n                        function self.setOrientationType(orientationType)\n                            local self={}\n                            local orientationType = orientationType\n                            local transX,transY=nil,nil\n                            function self.setTranslation(translateX,translateY)\n                                transX,transY=translateX,translateY\n                                return self\n                            end\n                            function self.build()\n                                return Object(style,pos,offset,orientation,positionType,orientationType,transX,transY)\n                            end\n                            return self\n                        end\n                        return self\n                    end\n                    return self\n                end\n                return self\n            end\n            return self\n        end\n        return self\n    end\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"4"},{"code":"local rad = math.rad\ncameraTypes={\n    fixed={\n        fLocal={\n            name=\"fLocal\",\n            pitchPos=nil,\n            pitchNeg=nil,\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,0}\n        },\n        fGlobal={\n            name=\"fGlobal\",\n            pitchPos=nil,\n            pitchNeg=nil,\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,0}\n        }\n    },\n    player={\n        jetpack={\n            name=\"jetpack\",\n            pitchPos=nil,\n            pitchNeg=nil,\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,0.9}\n        },\n        planet={\n            name=\"planet\",\n            pitchPos=rad(75),\n            pitchNeg=rad(-75),\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,0.85}\n        },\n        construct={\n            name=\"construct\",\n            pitchPos=rad(75),\n            pitchNeg=rad(-75),\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,0.85}\n        },\n        chair={\n            firstPerson={\n                mouseControlled={\n                    name=\"chairfp_mouse\",\n                    pitchPos=nil,\n                    pitchNeg=nil,\n                    headingPos=nil,\n                    headingNeg=nil,\n                    shift={-0.1,0,0.65}\n                },\n                freelook={\n                    name=\"chairfp_free\",\n                    pitchPos=rad(75),\n                    pitchNeg=rad(-75),\n                    headingPos=rad(95),\n                    headingNeg=rad(-95),\n                    shift={-0.1,0,0.65}\n                }\n            },\n            secondPerson={\n                name=\"chairsp\",\n                pitchPos=0,\n                pitchNeg=0,\n                headingPos=0,\n                headingNeg=0,\n                shift={0,0,0}\n            },\n            thirdPerson={\n                name=\"chairtp\",\n                pitchPos=rad(84),\n                pitchNeg=rad(-89),\n                headingPos=nil,\n                headingNeg=nil,\n                shift={0,0,0}\n            }\n        }\n    }\n}\n\nlocal hp=core.getHitPoints()\nlocal cOff=16\nif hp>10000 then cOff=128\nelseif hp>1000 then cOff=64\nelseif hp>150 then cOff=32\nend\n\nlocal function getChairPositions()\n    local eL=core.getElementIdList()\n    local eT=core.getElementTypeById\n    local ePos=core.getElementPositionById\n    local cOff=cOff\n    local pL={}\n    local c=1\n    for i=1, #eL do\n        local el=eT(eL[i])\n        if el==\"Gunner Module\" then\n            local eP=ePos(eL[i])\n            pL[c]={-(eP[1]-cOff),eP[2]-cOff,eP[3]-cOff}\n            c=c+1\n        end\n        if el==\"Command Seat Controller\" then\n            local eP=ePos(eL[i])\n            pL[c]={-(eP[1]-cOff),eP[2]-cOff,eP[3]-cOff}\n            c=c+1\n        end\n        if el==\"Wooden Chair\" then\n            local eP=ePos(eL[i])\n            pL[c]={-(eP[1]-cOff),eP[2]-cOff,eP[3]-cOff}\n            c=c+1\n        end\n        if el==\"Hovercraft Seat Controller\" then\n            local eP=ePos(eL[i])\n            pL[c]={-(eP[1]-cOff),eP[2]-cOff,eP[3]-cOff}\n            c=c+1\n        end\n    end\n    return pL\nend\n\nfunction Camera(camType, position, orientation)\n    local core=core\n    local system=system\n    local unit=unit\n    local planetaryInfluence=unit.getClosestPlanetInfluence\n    \n    local isViewLocked = false\n    \n    local print,types,rad,abs=system.print,cameraTypes,math.rad,math.abs\n    local chairs = getChairPositions()\n    local position = {-position[1], position[2], position[3]}\n    local self = {\n        cType = camType,\n        position = position, \n        orientation = {rad(orientation[1]), rad(orientation[2]), rad(orientation[3])},\n        isViewLocked = isViewLocked,\n        cameraShift\n    }\n    \n    function self.rotateHeading(heading) self.orientation[2]=self.orientation[2]+rad(heading) end\n    function self.rotatePitch(pitch) self.orientation[1]=self.orientation[1]+rad(pitch) end\n    function self.rotateRoll(roll) self.orientation[3]=self.orientation[3]+rad(roll) end\n    function self.setAlignmentType(alignmentType) self.cType = alignmentType end\n    function self.setPosition(pos) self.position={-pos[1],pos[2],pos[3]} end\n    function self.setViewLock(isViewLocked) self.isViewLocked = isViewLocked end\n    \n    function self.getAlignmentType(ax,ay,az,aw,bodyX,bodyY,bodyZ)\n        local playerType=types.player\n        local alignmentType=playerType.construct\n        if self.cType.name==\"fLocal\" then\n            alignmentType=types.fixed.fLocal\n            return alignmentType\n        elseif self.cType.name==\"fGlobal\" then\n            alignmentType=types.fixed.fGlobal\n            return alignmentType\n        end\n        if ax~=nil then\n            if ax>0.001 or ax<-0.001 or ay>0.001 or ay<-0.001 then alignmentType=playerType.jetpack end\n            if planetaryInfluence() > 0.85 then alignmentType=playerType.planet end\n        \n            local chairs=chairs\n            local bodyX=bodyX\n            local bodyY=bodyY\n            local bodyZ=bodyZ\n            local abs=abs\n            for i=1,#chairs do\n                local chairPos=chairs[i]\n                local difX=abs(chairPos[1]-bodyX)\n                local difY=abs(chairPos[2]-bodyY)\n                local difZ=abs(chairPos[3]-bodyZ)\n\n                if difX<0.4 and difY<0.4 and difZ<0.4 then\n                    local switch=switched%3\n                    if switch==0 then\n                        local fp=playerType.chair.firstPerson\n                        if self.isViewLocked then\n                            alignmentType=fp.mouseControlled\n                        else\n                            alignmentType=fp.freelook\n                        end\n                        return alignmentType\n                    elseif switch==1 then\n                        alignmentType=playerType.chair.thirdPerson\n                        return alignmentType\n                    elseif switch==2 then\n                        alignmentType=playerType.chair.secondPerson\n                        return alignmentType\n                    end\n                end\n            end\n        end\n        switched=0\n        return alignmentType\n    end\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"5"},{"code":"function getManager()\n    local self = {}\n    -- Misc function calls\n    local solve=library.systemResolution3\n    local gPWP=system.getPlayerWorldPos\n    local sqrt,atan,asin,print=math.sqrt,math.atan,math.asin,system.print\n    --- Core-based function calls\n    local gCWP=core.getConstructWorldPos\n    local gCWOR,gCWOF,gCWOU,gCLOR,gCLOF,gCLOU=core.getConstructWorldOrientationRight,core.getConstructWorldOrientationForward,core.getConstructWorldOrientationUp,core.getConstructOrientationRight,core.getConstructOrientationForward,core.getConstructOrientationUp\n    local gEPBI=core.getElementPositionById\n    local mul,div,inv,rTQ,gTWP,gWTLC,gLTWC=nil,nil,nil,nil,nil,nil,nil\n    \n    local hp=core.getMaxHitPoints()\n    local cOff=16\n    if hp>10000 then cOff=128\n    elseif hp>1000 then cOff=64\n    elseif hp>150 then cOff=32\n    end\n    local function correct(v)\n        local lr,lf,lu=gCLOR(),gCLOF(),gCLOU()\n        return solve(lr,lf,lu,v)\n    end\n    function self.getLocalToWorldConverter()\n        local s=solve\n        local r,f,u=gCWOR(),gCWOF(),gCWOU()\n        return function(c) c=correct(c) return s(s(r,f,u,{1,0,0}),s(r,f,u,{0,1,0}),s(r,f,u,{0,0,1}),c) end\n    end\n\n    function self.getWorldToLocalConverter()\n        local lr,lf,lu,r,f,u=gCLOR(),gCLOF(),gCLOU(),gCWOR(),gCWOF(),gCWOU()\n\n        local matrix1,matrix2={lr[1],lr[2],lr[3],0,lf[1],lf[2],lf[3],0,lu[1],lu[2],lu[3],0},{r[1],r[2],r[3],0,f[1],f[2],f[3],0,u[1],u[2],u[3],0}\n        \n        local ax,ay,az,aw=inv(rTQ(matrix1))\n        local bx,by,bz,bw=rTQ(matrix2)\n        local wx,wy,wz,ww=mul(ax,ay,az,aw,bx,by,bz,bw)\n        \n        local wxwx,wxwy,wxwz,wxww,wywy,wywz,wyww,wzwz,wzww=wx*wx,wx*wy,wx*wz,wx*ww,wy*wy,wy*wz,wy*ww,wz*wz,wz*ww\n        return function(w) return solve({1-2*(wywy+wzwz),2*(wxwy-wzww),2*(wxwz+wyww)},{2*(wxwy+wzww),1-2*(wxwx+wzwz),2*(wywz-wxww)},{2*(wxwz-wyww),2*(wywz+wxww),1-2*(wxwx+wywy)},w) end\n    end\n    function self.getTrueWorldPos()\n        local cal1=gLTWC()\n        local cal2=gWTLC()\n        local cWP=gCWP()\n        local p=gEPBI(1)\n        local offsetPosition={p[1]-cOff,p[2]-cOff,p[3]-cOff}\n        local adj=cal1(offsetPosition)\n        local adjPos={cWP[1]-adj[1],cWP[2]-adj[2],cWP[3]-adj[3]}\n        return adjPos\n    end\n    function self.getPlayerLocalPos(playerId)\n        local c=gWTLC()\n        local cWP=gTWP()\n        local pWP=gPWP(playerId)\n        local adjPos=c({pWP[1]-cWP[1],pWP[2]-cWP[2],pWP[3]-cWP[3]})\n        adjPos={-adjPos[1],adjPos[2],adjPos[3]}\n        return adjPos\n    end\n    function self.rotMatrixToQuat(rM)\n        local m11,m21,m31,m12,m22,m32,m13,m23,m33=rM[1],rM[5],rM[9],rM[2],rM[6],rM[10],rM[3],rM[7],rM[11]\n        local t=m11+m22+m33\n        if t>0 then\n            local s=0.5/sqrt(t+1)\n            return (m32-m23)*s,(m13-m31)*s,(m21-m12)*s,0.25/s\n        elseif m11>m22 and m11>m33 then\n            local s = 2*sqrt(1+m11-m22-m33)\n            return 0.25*s,(m12+m21)/s,(m13+m31)/s,(m32-m23)/s\n        elseif m22>m33 then\n            local s=2*sqrt(1+m22-m11-m33)\n            return (m12+m21)/s,0.25*s,(m23+m32)/s,(m13-m31)/s\n        else\n            local s=2*sqrt(1+m33-m11- m22)\n            return (m13+m31)/s,(m23+m32)/s,0.25*s,(m21-m12)/s\n        end\n    end\n    function self.inverse(qX,qY,qZ,qW)\n        local mag=qX*qX+qY*qY+qZ*qZ+qW*qW\n        return -qX/mag,-qY/mag,-qZ/mag,qW/mag\n    end\n    function self.multiply(ax,ay,az,aw,bx,by,bz,bw)\n        return ax*bw+aw*bx+ay*bz-az*by,ay*bw+aw*by+az*bx-ax*bz,az*bw+aw*bz+ax*by-ay*bx,aw*bw-ax*bx-ay*by-az*bz\n    end\n    function self.divide(ax,ay,az,aw,bx,by,bz,bw)\n        local cx,cy,cz,cw=inv(bx,by,bz,bw)\n        return mul(ax,ay,az,aw,cx,cy,cz,cw)\n    end\n    mul,div,inv,rTQ,gTWP,gWTLC,gLTWC=self.multiply,self.divide,self.inverse,self.rotMatrixToQuat,self.getTrueWorldPos,self.getWorldToLocalConverter,self.getLocalToWorldConverter\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"6"}],"methods":[],"events":[]}